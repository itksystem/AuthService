const db = require('openfsm-database-connection-producer');
const { UserPermissionsDTO, RoleDTO, PermissionDTO } = require('openfsm-permissions-dto');
const { UserDTO } = require('openfsm-user-dto');
const common      = require('openfsm-common-auth-services');  /* Библиотека с общими параметрами для Auth*/
const crypto      = require('crypto');
const logger      = require('openfsm-logger-handler');
const ClientProducerAMQP  =  require('openfsm-client-producer-amqp'); // ходим в почту через шину
require('dotenv').config();

const {RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE, RABBITMQ_MAIL_QUEUE, RABBITMQ_TWO_PA_CHANGE_STATUS_QUEUE  } = process.env;
const PAYMENT_ACCOUNT_CREATE_QUEUE = RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE || 'PAYMENT_ACCOUNT_CREATE';
exports.MAIL_QUEUE  = RABBITMQ_MAIL_QUEUE || 'MAIL';
exports.MAIL_QUEUE  = RABBITMQ_MAIL_QUEUE || 'MAIL';
exports.TWO_PA_CHANGE_STATUS_QUEUE = RABBITMQ_TWO_PA_CHANGE_STATUS_QUEUE || 'TWO_PA_CHANGE_STATUS_QUEUE';


exports.emailVerificationLink = () => {
  const tokenLength = 255; // Генерация случайного токена  
  const token = crypto.randomBytes(Math.ceil(tokenLength / 2)).toString('hex').slice(0, tokenLength); // Ограничиваем длину
  return token;  
};

exports.verificationCode = () => {  
    return Math.floor(10000 + Math.random() * 90000).toString();
};

exports.create = async (email, password) => {
  if (!email || !password) {
    return Promise.reject(new Error('Email и пароль обязательны.'));
  }
  try {
    const verificationCode = exports.verificationCode();
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.CREATE, [email, password, verificationCode], (err, result) => {
        if (err) {
          logger.error(err);
          return reject(err);
        }
        resolve(result);
      });
    });

    return Number(result.rows[0].id);
  } catch (error) {
    logger.error('Ошибка при создании пользователя:', error);
    throw error;
  }
};

exports.telegramCreate = async (hashedPassword) => {
  if (!hashedPassword) {
    return Promise.reject(new Error('telegramCreate. hashedPassword requred.'));
  }
  try {
    const verificationCode = exports.verificationCode();
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.TELEGRAM_CREATE, [ hashedPassword, verificationCode], (err, result) => {
        if (err) {
          logger.error(err);
          return reject(err);
        }
        resolve(result);
      });
    });

    return Number(result?.rows[0]?.id ?? null);
  } catch (error) {
    logger.error('Ошибка при создании пользователя:', error);
    throw error;
  }
};

exports.setCustomerRole = (userId, roleId) => {  // Установить изначальную роль - клиент
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.ASSIGN_ROLE, [userId, roleId], (err, result) => {
      if (err) {
          logger.error(err);
          return reject(false);
      }
      if (!result) {
          return resolve(false); // Установить роль
      }
      resolve(true);
    });
  });
};

exports.findByEmail = async (email) => {
  if (!email || email.trim() === '') {
    throw new Error('Email обязателен для поиска пользователя.');
  }

  try {
    // Выполнение SQL-запроса с использованием promise
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.FIND_BY_EMAIL, [email], (err, result) => {
        if (err) {
          console.log(err);
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result.rows[0]);
      });
    });

    // Если пользователь не найден, возвращаем null
    if (!result) {
      logger.info(`Пользователь с email ${email} не найден.`);
      return null;
    }
    // Создаем и возвращаем экземпляр UserDTO
     return new UserDTO(result);
  } catch (error) {
    console.log(error);
    logger.error('Ошибка при поиске пользователя по email:', error);
    throw error;
  }
};



exports.findById = async (id) => {
  if (!id) {
    throw new Error('ID обязателен для поиска пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.FIND_BY_ID, [id], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result.rows[0]);
      });
    });

    if (!result) {
      console.log(`Пользователь с ID ${id} не найден.`);
      return null;
    }

    return new UserDTO(result);
  } catch (error) {
    logger.error('Ошибка при поиске пользователя по ID:', error);
    throw error;
  }
};

exports.findByTelegramId = async (id) => {
  if (!id) {
    throw new Error('TelegramId обязателен для поиска пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.FIND_BY_TELEGRAM_ID, [id], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result.rows[0]);
      });
    });

    if (!result) {
      logger.info(`Пользователь с ID ${id} не найден.`);
      return null;
    }

    return new UserDTO(result);
  } catch (error) {
    logger.error('Ошибка при поиске пользователя по ID:', error);
    throw error;
  }
};



exports.update = async (id, name, email) => {
  if (!id || !name || !email) {
    throw new Error('ID, имя и email обязательны для обновления пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.UPDATE_BY_ID, [name, email, id], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result);
      });
    });

    if (result.affectedRows === 0) {
      logger.info(`Пользователь с ID ${id} не найден для обновления.`);
      return null;
    }

    logger.info(`Пользователь с ID ${id} успешно обновлен.`);
    return result;
  } catch (error) {
    logger.error('Ошибка при обновлении пользователя:', error);
    throw error;
  }
};


exports.getPermissions = (id) => {
  return new Promise((resolve, reject) => {
          
    db.query(common.SQL.USER.GET_ROLES, [id], (err, roleResult) => {    
      if (err) {
        logger.error(err)
        return reject(err);
      }

      // Создание массивов RoleDTO
      let roles = roleResult.rows.map(row => new RoleDTO(row.roles, row.description));
      db.query(common.SQL.USER.GET_PERMISSIONS, [id], (err, permissionResult) => {        
        if (err) {
          logger.error(err)
          return reject(err);
        }
        // Создание массивов PermissionDTO
        const permissions = permissionResult.rows.map(row => new PermissionDTO(row.permissions, row.description)); 
        const userPermissionsDTO = new UserPermissionsDTO(roles, permissions);
        resolve({
          roles: userPermissionsDTO.getRoles(), // получение в формате { roleCode: "..." }
          permissions: userPermissionsDTO.getPermissions() // получение в формате { permCode: "..." }
        });
      });
    });
  });
};



// Получение данных пользователя
exports.getMe = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_ME, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении данных пользователя:', err);
          return reject(err);
        }
        resolve(result.rows[0] || null); // Возвращаем `null`, если данных нет
      });
    });
    return result;
  } catch (error) {
    logger.error('Ошибка в getMe:', error);
    throw error;
  }
};


// Получение кода верификации
exports.getVerificationCode = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_VERIFICATION_CODE, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result[0]?.verificationCode || null); // Возвращаем `null`, если данных нет
      });
    });
    return result;
  } catch (error) {
    logger.error('Ошибка в getVerificationCode:', error);
    throw error;
  }
};

// Смена кода верификации
exports.changeVerificationCode = async (userId, newCode) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_VERIFICATION_CODE, [newCode, userId], (err) => {
        if (err) {
          logger.error('Ошибка при смене кода верификации:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в changeVerificationCode:', error);
    return false;
  }
};

// Установка статуса "подтвержден"
exports.setConfirmed = async (userId) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_EMAIL_CONFIRMED, [userId], (err) => {
        if (err) {
          logger.error('Ошибка при установке статуса подтвержден:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в setConfirmed:', error);
    return false;
  }
};

// Установка статуса "не подтвержден"
exports.setUnConfirmed = async (userId) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_EMAIL_UNCONFIRMED, [userId], (err) => {
        if (err) {
          logger.error('Ошибка при установке статуса не подтвержден:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в setUnConfirmed:', error);
    return false;
  }
};


// Список вопросов для подтверждения 
exports.getTwoFactorList = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_TWO_FACTOR_LIST, [], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getTwoFactorList:', error);
    throw error;
  }
};


// Установка второго фактора пользователю
exports.setTwoFactor = async (userId, factorId, factorText, factorHash) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_TWO_FACTOR, [userId, factorId, factorText, factorHash], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в setTwoFactor:', error);
    throw error;
  }
};


exports.getTwoFactor = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_TWO_FACTOR, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getTwoFactor:', error);
    throw error;
  }
};

exports.getPinCodeFactor = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_PIN_CODE_FACTOR, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getPinCodeFactor:', error);
    throw error;
  }
};


exports.getSecurityQuestion = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_SECURITY_QUESTION, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getSequrityQuestion:', error);
    throw error;
  }
};

// Отключение контрольного вопроса
exports.disableSecurityQuestion = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.DISABLE_TWO_FACTOR, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getSequrityQuestion:', error);
    throw error;
  }
};

// Отключение PIN кода
exports.disablePINCodeQuestion = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.DISABLE_PIN_CODE, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getSequrityQuestion:', error);
    throw error;
  }
};


exports.getSecurityAnswer = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_SECURITY_FACTOR_KEY, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result); 
      });
    });
    return result.rows[0] || null; // Возвращаем `null`, если данных нет
  } catch (error) {
    logger.error('Ошибка в getSequrityQuestion:', error);
    throw error;
  }
};


// Отправка сообщения в очередь RabbitMQ
exports.sendMessage = async (queue, msg) => {
  try {
    const rabbitClient = new ClientProducerAMQP();
    await rabbitClient.sendMessage(queue, msg);
    return true;
  } catch (error) {
    logger.error('Ошибка при отправке сообщения в RabbitMQ:', error);
    return false;
  }
};


// Отправка сообщения в очередь RabbitMQ - создание счета
exports.createAccounMessageSend = async (userId = null) => {
  try {
    if(userId == null) throw('userId is null')
     let message = {};
     message.userId = userId;
     const rabbitClient = new ClientProducerAMQP();    
     await rabbitClient.sendMessage(PAYMENT_ACCOUNT_CREATE_QUEUE, message);
     console.log(message)
    return true;
  } catch (error) {
    logger.error('Ошибка при отправке сообщения в RabbitMQ:', error);
    return false;
  }
};

exports.getRegistrationMail = (user) => {
 let message = {};
  message.transport = "mail";
  message.template = "NEW_USER_NOTIFICATION";
  message.to = user.getEmail();
  message.subject = "Добро пожаловать на PICKMAX.RU - ваш супермаркет в Интернет! ";
  message.text = "test";
  message.variables = {};
  message.variables.HOST_NAME = "PICKMAX.RU";
  message.variables.HOST = "pickmax.ru"; 
  message.variables.CODE = user.getVerificationCode(); 
 return message || null;
};


exports.getNewVerificationCodeMail = (user) => {
  let message = {};
   message.transport = "mail";
   message.template = "RETRY_VERIFICATION_CODE_NOTIFICATION";
   message.to = user.getEmail();
   message.subject = "Запрос нового кода верификации!";
   message.text = "";
   message.variables = {};
   message.variables.HOST_NAME = "PICKMAX.RU";
   message.variables.HOST = "pickmax.ru"; 
   message.variables.CODE = user.getVerificationCode(); 
  return message || null;
 };
 

 