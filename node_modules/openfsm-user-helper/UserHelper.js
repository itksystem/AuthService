const db = require('openfsm-database-connection-producer');
const { UserPermissionsDTO, RoleDTO, PermissionDTO } = require('openfsm-permissions-dto');
const { UserDTO } = require('openfsm-user-dto');
const common      = require('openfsm-common');  /* Библиотека с общими параметрами */


exports.create = (email, password, name) => {
  return new Promise((resolve, reject) => {  
    db.query(common.SQL.USER.CREATE, [email, password, name], (err, result) => {
      (err) 
        ? reject(err)
        : resolve(result.insertId);
    });
  });
};

exports.setCustomerRole = (userId, roleId) => {  // Установить изначальную роль - клиент
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.ASSIGN_ROLE, [userId, roleId], (err, result) => {
      (err) 
        ? reject(false)
        : resolve(true);
    });
  });
};

exports.findByEmail = (email) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.FIND_BY_EMAIL, [email], (err, result) => {
    (err) 
     ? reject(err)
     : resolve(result.length > 0 ? new UserDTO(result[0]) : null );
    });
  });
};

exports.findById = (id) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.FIND_BY_ID, [id], (err, result) => {
      (err)
      ? reject(err)
      : resolve(new UserDTO(result[0]));
    });
  });
};

exports.update = (id, name, email) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.UPDATE_BY_ID, [name, email,  id], (err, result) => {
      (err) 
      ? reject(err)
      : resolve(result);
    });
  });
};


exports.getPermissions = (id) => {
  return new Promise((resolve, reject) => {
    
    let sqlRoles = `
      SELECT DISTINCT(r.name) AS roles, r.description
      FROM users u
      JOIN user_roles ur ON u.id = ur.user_id
      JOIN roles r ON r.id = ur.role_id
      WHERE u.id = ? and u.blocked is null`;
      
    db.query(sqlRoles, [id], (err, roleResult) => {
      if (err) {
        return reject(err);
      }

      // Создание массивов RoleDTO
      let roles = roleResult.map(row => new RoleDTO(row.roles, row.description));
      
      let sqlPermissions = `
        SELECT DISTINCT(p.name) AS permissions, p.description
        FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN role_permissions rp ON ur.role_id = rp.role_id
        JOIN permissions p ON rp.permission_id = p.id
        WHERE u.id = ? and u.blocked is null`;

      db.query(sqlPermissions, [id], (err, permissionResult) => {
        if (err) {
          return reject(err);
        }

        // Создание массивов PermissionDTO
        const permissions = permissionResult.map(row => new PermissionDTO(row.permissions, row.description)); 
        
        const userPermissionsDTO = new UserPermissionsDTO(roles, permissions);
        
        resolve({
          roles: userPermissionsDTO.getRoles(), // получение в формате { roleCode: "..." }
          permissions: userPermissionsDTO.getPermissions() // получение в формате { permCode: "..." }
        });
      });
    });
  });
};

exports.revokeToken  = (token) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.REVOKE_TOKEN, [token], (err, result) => {
      (err)
      ? reject(false)
      : resolve(true);
    });
  });
};

exports.isTokenRevoked = (token) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.IS_TOKEN_REVOKED, [token], (err, result) => {
      (err)
      ? reject(false)
      : resolve(true);
    });
  });
};

exports.getMe = (userId) => {
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.GET_ME, [userId], (err, result) => {
      (err)
      ? reject(null)
      : resolve(result[0]);
    });
  });
};