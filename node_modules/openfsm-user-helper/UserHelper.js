const db = require('openfsm-database-connection-producer');
const { UserPermissionsDTO, RoleDTO, PermissionDTO } = require('openfsm-permissions-dto');
const { UserDTO } = require('openfsm-user-dto');
const common      = require('openfsm-common');  /* Библиотека с общими параметрами */
const crypto = require('crypto');
const logger = require('openfsm-logger-handler');
// const MailNotificationProducer  =  require('openfsm-mail-notification-producer'); // ходим в почту через шину
const ClientProducerAMQP  =  require('openfsm-client-producer-amqp'); // ходим в почту через шину
// const amqp = require('amqplib');
require('dotenv').config();

const {RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE, RABBITMQ_MAIL_QUEUE  } = process.env;
exports.PAYMENT_ACCOUNT_CREATE_QUEUE = RABBITMQ_PAYMENT_ACCOUNT_CREATE_QUEUE || 'PAYMENT_ACCOUNT_CREATE';
exports.MAIL_QUEUE  = RABBITMQ_MAIL_QUEUE || 'MAIL';


exports.emailVerificationLink = () => {
  const tokenLength = 255; // Генерация случайного токена  
  const token = crypto.randomBytes(Math.ceil(tokenLength / 2)).toString('hex').slice(0, tokenLength); // Ограничиваем длину
  return token;  
};

exports.verificationCode = () => {  
    return Math.floor(10000 + Math.random() * 90000).toString();
};

exports.create = async (email, password) => {
  if (!email || !password) {
    return Promise.reject(new Error('Email и пароль обязательны.'));
  }
  try {
    const verificationCode = exports.verificationCode();
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.CREATE, [email, password, verificationCode], (err, result) => {
        if (err) {
          logger.error(err);
          return reject(err);
        }
        resolve(result);
      });
    });

    return result.insertId;
  } catch (error) {
    logger.error('Ошибка при создании пользователя:', error);
    throw error;
  }
};


exports.setCustomerRole = (userId, roleId) => {  // Установить изначальную роль - клиент
  return new Promise((resolve, reject) => {    
    db.query(common.SQL.USER.ASSIGN_ROLE, [userId, roleId], (err, result) => {
      if (err) {
          logger.error(err);
          return reject(false);
      }
      if (!result) {
          return resolve(false); // Установить роль
      }
      resolve(true);
    });
  });
};

exports.findByEmail = async (email) => {
  if (!email) {
    throw new Error('Email обязателен для поиска пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.FIND_BY_EMAIL, [email], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result);
      });
    });

    if (!result || result.length === 0) {
      logger.info(`Пользователь с email ${email} не найден.`);
      return null;
    }

    return new UserDTO(result[0]);
  } catch (error) {
    logger.error('Ошибка при поиске пользователя по email:', error);
    throw error;
  }
};


exports.findById = async (id) => {
  if (!id) {
    throw new Error('ID обязателен для поиска пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.FIND_BY_ID, [id], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result);
      });
    });

    if (!result || result.length === 0) {
      logger.info(`Пользователь с ID ${id} не найден.`);
      return null;
    }

    return new UserDTO(result[0]);
  } catch (error) {
    logger.error('Ошибка при поиске пользователя по ID:', error);
    throw error;
  }
};


exports.update = async (id, name, email) => {
  if (!id || !name || !email) {
    throw new Error('ID, имя и email обязательны для обновления пользователя.');
  }

  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.UPDATE_BY_ID, [name, email, id], (err, result) => {
        if (err) {
          logger.error('Ошибка выполнения SQL-запроса:', err);
          return reject(err);
        }
        resolve(result);
      });
    });

    if (result.affectedRows === 0) {
      logger.info(`Пользователь с ID ${id} не найден для обновления.`);
      return null;
    }

    logger.info(`Пользователь с ID ${id} успешно обновлен.`);
    return result;
  } catch (error) {
    logger.error('Ошибка при обновлении пользователя:', error);
    throw error;
  }
};


exports.getPermissions = (id) => {
  return new Promise((resolve, reject) => {
    
    let sqlRoles = `
      SELECT DISTINCT(r.name) AS roles, r.description
      FROM users u
      JOIN user_roles ur ON u.id = ur.user_id
      JOIN roles r ON r.id = ur.role_id
      WHERE u.id = ? and u.blocked is null`;
      
    db.query(sqlRoles, [id], (err, roleResult) => {    
      if (err) {
        logger.error(err)
        return reject(err);
      }

      // Создание массивов RoleDTO
      let roles = roleResult.map(row => new RoleDTO(row.roles, row.description));
      
      let sqlPermissions = `
        SELECT DISTINCT(p.name) AS permissions, p.description
        FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN role_permissions rp ON ur.role_id = rp.role_id
        JOIN permissions p ON rp.permission_id = p.id
        WHERE u.id = ? and u.blocked is null`;

      db.query(sqlPermissions, [id], (err, permissionResult) => {        
        if (err) {
          logger.error(err)
          return reject(err);
        }

        // Создание массивов PermissionDTO
        const permissions = permissionResult.map(row => new PermissionDTO(row.permissions, row.description)); 
        
        const userPermissionsDTO = new UserPermissionsDTO(roles, permissions);
        
        resolve({
          roles: userPermissionsDTO.getRoles(), // получение в формате { roleCode: "..." }
          permissions: userPermissionsDTO.getPermissions() // получение в формате { permCode: "..." }
        });
      });
    });
  });
};



// Получение данных пользователя
exports.getMe = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_ME, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении данных пользователя:', err);
          return reject(err);
        }
        resolve(result[0] || null); // Возвращаем `null`, если данных нет
      });
    });
    return result;
  } catch (error) {
    logger.error('Ошибка в getMe:', error);
    throw error;
  }
};

// Проверка подтверждения пользователя
exports.isConfirmed = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_CONFIRMED, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при проверке подтверждения пользователя:', err);
          return reject(err);
        }
        resolve(result[0]?.isConfirmed || false); // Предполагается, что поле isConfirmed
      });
    });
    return result;
  } catch (error) {
    logger.error('Ошибка в isConfirmed:', error);
    throw error;
  }
};

// Получение кода верификации
exports.getVerificationCode = async (userId) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.GET_VERIFICATION_CODE, [userId], (err, result) => {
        if (err) {
          logger.error('Ошибка при получении кода верификации:', err);
          return reject(err);
        }
        resolve(result[0]?.verificationCode || null); // Возвращаем `null`, если данных нет
      });
    });
    return result;
  } catch (error) {
    logger.error('Ошибка в getVerificationCode:', error);
    throw error;
  }
};

// Смена кода верификации
exports.changeVerificationCode = async (userId, newCode) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_VERIFICATION_CODE, [newCode, userId], (err) => {
        if (err) {
          logger.error('Ошибка при смене кода верификации:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в changeVerificationCode:', error);
    return false;
  }
};

// Установка статуса "подтвержден"
exports.setConfirmed = async (userId) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_CONFIRMED, [userId], (err) => {
        if (err) {
          logger.error('Ошибка при установке статуса подтвержден:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в setConfirmed:', error);
    return false;
  }
};

// Установка статуса "не подтвержден"
exports.setUnConfirmed = async (userId) => {
  try {
    await new Promise((resolve, reject) => {
      db.query(common.SQL.USER.SET_UNCONFIRMED, [userId], (err) => {
        if (err) {
          logger.error('Ошибка при установке статуса не подтвержден:', err);
          return reject(err);
        }
        resolve();
      });
    });
    return true;
  } catch (error) {
    logger.error('Ошибка в setUnConfirmed:', error);
    return false;
  }
};

// Отправка сообщения в очередь RabbitMQ
exports.sendMessage = async (queue, msg) => {
  try {
    const rabbitClient = new ClientProducerAMQP();
    await rabbitClient.sendMessage(queue, msg);
    return true;
  } catch (error) {
    logger.error('Ошибка при отправке сообщения в RabbitMQ:', error);
    return false;
  }
};


exports.getRegistrationMail = (user) => {
 let message = {};
  message.transport = "mail";
  message.template = "NEW_USER_NOTIFICATION";
  message.to = user.getEmail();
  message.subject = "Добро пожаловать на PICKMAX.RU - ваш супермаркет в Интернет! ";
  message.text = "test";
  message.variables = {};
  message.variables.HOST_NAME = "PICKMAX.RU";
  message.variables.HOST = "pickmax.ru"; 
  message.variables.CODE = user.getVerificationCode(); 
 return message || null;
};


exports.getNewVerificationCodeMail = (user) => {
  let message = {};
   message.transport = "mail";
   message.template = "RETRY_VERIFICATION_CODE_NOTIFICATION";
   message.to = user.getEmail();
   message.subject = "Запрос нового кода верификации!";
   message.text = "";
   message.variables = {};
   message.variables.HOST_NAME = "PICKMAX.RU";
   message.variables.HOST = "pickmax.ru"; 
   message.variables.CODE = user.getVerificationCode(); 
  return message || null;
 };
 

